(ns constraint-processing.sfa
  "Utilities to facilitate the creation, validation, and manipulation of SFAs."
  (:require [constraint-processing.paths :as paths]
            [constraint-processing.ranges :as ranges]
            [clojure.string :as str]
            [clojure.set :as set]
            [clojure.pprint :refer [pprint]]
            [clojure.java.shell :as sh]
            [com.rpl.specter :as sp]
            [constraint-processing.table :as table]))

(defn state-predicates
  "Returns a mapping from state number to predicates on transitions in `sfa`
  leading out of that state."
  [sfa]
  (reduce (fn [acc state]
            (assoc acc state (set (sp/select [:transitions state sp/ALL :input] sfa))))
          {}
          (:states sfa)))

(defn- predicates->transitions
  "Given a set of `predicates`, return a seq of transitions that form self loops on
  `state`, and are marked as artificial."
  [predicates state]
  (map (fn [pred]
         {:from state, :input pred, :to state, :artificial true}) predicates))

(defn complete?
  "Returns true if `sfa` is complete (i.e. has transitions out of every state
  that cover the entire input domain)."
  [sfa]
  (let [total-range-per-state
        (reduce (fn [acc [state predicates]]
                  (assoc acc state (ranges/get-largest-range predicates)))
                {}
                (state-predicates sfa))
        nil-states (sp/select [sp/MAP-VALS (sp/pred #(or (nil? %) (not= % [0 Integer/MAX_VALUE])))] total-range-per-state)]
    (empty? nil-states)))

(defn complete
  "Return `sfa` where all incomplete transitions have been filled in."
  [sfa]
  (let [state-predicates (state-predicates sfa)]
    (reduce (fn [sfa state]
              (update-in sfa [:transitions state]
                         #(vec (concat % (flatten (predicates->transitions (ranges/get-completing-preds (sp/select [state sp/ALL] state-predicates)) state))))))
            sfa
            (:states sfa))))

(defn execute-sfa
  "Returns the acceptance state of `sfa` after running `input` on it.
  True for accept, false for reject."
  [sfa input]
  (loop [state (:initial-state sfa)
         input input]
    (if (empty? input)
      (contains? (:final-states sfa) state)
      (let [trans (first (filter #(ranges/intersects? (:input %) [(first input) (first input)])
                                 (get (:transitions sfa) state)))]
        (recur (:to trans) (rest input))))))

(defn run-all-from-db
  "Run every input from `db` through `sfa` and compare to the expected result.
  Returns true if all results match expected."
  [sfa db]
  (let [paths (paths/sorted-paths db)]
    (loop [paths paths]
      (if (empty? paths)
        true
        (let [path (first paths)
              should-accept (:accepted path)
              input (paths/make-concrete (:path path))
              accepted (execute-sfa sfa input)]
          (if (= accepted should-accept)
            (recur (rest paths))
            path))))))

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SFA display functions
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn sfa->dot
  "Return the dot markup that draws a representation of `sfa`."
  [sfa]
  (let [header "digraph finite_state_machine { \nrankdir=LR; size=\"8.5\"\n "
        final-state-style (str "node [ shape = doublecircle]; " (str/join "; " (:final-states sfa)) ";\n")
        initial-state-style (str "node [ shape = point ]; qi;\n")
        normal-state-style (str "node [ shape = circle ];\n")
        first-transition (str "qi -> " (:initial-state sfa) ";\n")
        transitions (reduce
                     (fn [trans-string {:keys [from to input]}]
                       (let [input (if (= (second input) Integer/MAX_VALUE) [(first input) "âˆž"] input)]
                         (str trans-string
                              "\n"
                              (if (nil? from) "nil" from)
                              " -> "
                              (if (nil? to) "nil" to)
                              " [ label = \"["
                              (first input) " "
                              (second input) "]\"];")))
                     ""
                     (apply concat (map second (filter map-entry? (:transitions sfa)))))
        footer "\n}"]
    (-> header
        (str final-state-style)
        (str initial-state-style)
        (str normal-state-style)
        (str first-transition)
        (str transitions)
        (str footer))))

(defn sfa->img
  "Display the image generated by calling `sfa->dot` on `sfa`."
  [sfa]
  (spit "tmp.dot" (sfa->dot sfa))
  (sh/sh "dot"
         (str "-Gdpi=" 300)
         (str "-T" "png")
         "tmp.dot"
         "-o"
         "tmp.png")
  (sh/sh "xdg-open" "tmp.png")
  (sh/sh "rm" "tmp.png")
  (sh/sh "rm" "tmp.dot"))

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Table to SFA conversion functions
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn get-prefix-pairs
  "Given an observation table, produce the proper prefix pairs, such that
  (len u1) == (dec (len u2)). These pairs are used to synthesize transitions."
  [table]
  (let [states (:S table)
        entries (set/union (:R table) (:S table))
        prefixes (reduce (fn [transitions entry]
                           (->> entries
                                (map (juxt identity
                                           (constantly entry)
                                           #(paths/prefix? (:path %) (:path entry))))
                                (filter last)
                                (into [])
                                (conj transitions)))
                         []
                         entries)]
    (->> prefixes
         (mapcat identity)
         (into []))))

(defn pair->transition
  "Return an SFA transition constructed from `prefix-pair`."
  [table prefix-pair]
  (let [[from to] prefix-pair
        from-row (:row from)
        to-row (:row to)]
    {:from (:path (table/row->entry table from-row))
     :input (last (:path to))
     :to (:path (table/row->entry table to-row))}))

(defn pairs->transitions
  "Transform pairs of rows from `prefix-pairs` into SFA transitions."
  [table prefix-pairs]
  (->> (for [[from to] prefix-pairs]
         (if (= from to)
           []
           (pair->transition table [from to])))
       (filter #(not= nil (:input %)))
       vec))

(defn get-transitions
  "Return the transitions encoded in `table`."
  [table]
  (let [states (:S table)
        prefix-pairs (get-prefix-pairs table)
        transitions (pairs->transitions table prefix-pairs)]
    transitions))

(defn get-state-map
  "Returns a mapping from paths in S to monotonic natural numbers."
  [table]
  (as-> table $
    (:S $)
    (map first $)
    (map second $)
    (map vector $ (iterate inc 0))
    (into {} $)))

(defn get-final-states
  "Returns a vector of final states, labeled as per `get-state-map`."
  [table state-map]
  (->> (:S table)
       (filter #(first (:row %)))
       (map :path)
       (map (partial get state-map))
       vec))

(defn table->sfa
  "Returns an SFA constructed from `table`. If information in `table` is not
  sufficient to construct a complete SFA, the incomplete SFA will be artificially
  completed."
  [table]
  (let [transitions (get-transitions table)
        state-map (get-state-map table)
        final-states (set (get-final-states table state-map))
        simple-transitions (reduce (fn [steps transition]
                                     (conj steps {:from (get state-map (:from transition))
                                                  :input (:input transition)
                                                  :to (get state-map (:to transition))}))
                                   #{}
                                   transitions)
        sfa {:transitions (group-by :from simple-transitions)
             :initial-state (get state-map [])
             :final-states final-states
             :states (set (vals state-map))}]
    (if-not (complete? sfa)
      (complete sfa)
      sfa)))
