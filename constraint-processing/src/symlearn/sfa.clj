(ns symlearn.sfa
  "Utilities to facilitate the creation, validation, and manipulation of SFAs."
  (:require [symlearn.paths :as paths]
            [symlearn.ranges :as ranges]
            [clojure.string :as str]
            [clojure.set :as set]
            [clojure.pprint :refer [pprint]]
            [clojure.java.shell :as sh]
            [com.rpl.specter :as sp]))

(set! *warn-on-reflection* true)

(defn state-predicates
  "Returns a mapping from state number to predicates on transitions in `sfa`
  leading out of that state."
  [sfa]
  (reduce (fn [acc state]
            (assoc acc state (set (sp/select [:transitions state sp/ALL :input] sfa))))
          {}
          (:states sfa)))

(defn- predicates->transitions
  "Given a set of `predicates`, return a seq of transitions that form self loops on
  `state`, and are marked as artificial."
  [predicates state]
  (map (fn [pred]
         {:from state, :input pred, :to state, :artificial true}) predicates))

(defn complete?
  "Returns true if `sfa` is complete (i.e. has transitions out of every state
  that cover the entire input domain)."
  [sfa]
  (let [total-range-per-state
        (reduce (fn [acc [state predicates]]
                  (assoc acc state (ranges/get-largest-range predicates)))
                {}
                (state-predicates sfa))
        nil-states (sp/select [sp/MAP-VALS (sp/pred #(or (nil? %) (not= % [0 Integer/MAX_VALUE])))] total-range-per-state)]
    (empty? nil-states)))

(defn complete
  "Return `sfa` where all incomplete transitions have been filled in."
  [sfa]
  (reduce (fn [sfa state]
            (update-in sfa [:transitions state]
                       #(vec (concat % (flatten (predicates->transitions (ranges/get-completing-predicates (sp/select [state sp/ALL] (state-predicates sfa))) state))))))
          sfa
          (:states sfa)))

(defn execute-sfa
  "Returns the acceptance state of `sfa` after running `input` on it.
  True for accept, false for reject."
  [sfa input]
  (loop [state (:initial-state sfa)
         input input]
    (if (empty? input)
      (contains? (:final-states sfa) state)
      (let [trans (first (filter #(ranges/intersects? (:input %) [(first input) (first input)])
                                 (get (:transitions sfa) state)))]
        (recur (:to trans) (rest input))))))

(defn run-all-from-db
  "Run every input from `db` through `sfa` and compare to the expected result.
  Returns true if all results match expected."
  [sfa db]
  (let [paths (paths/sorted-paths db)]
    (loop [paths paths]
      (if (empty? paths)
        true
        (let [path (first paths)
              should-accept (:accepted path)
              input (paths/make-concrete (:path path))
              accepted (execute-sfa sfa input)]
          (if (= accepted should-accept)
            (recur (rest paths))
            path))))))

;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SFA display functions
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defn sfa->dot
  "Return the dot markup that draws a representation of `sfa`."
  [sfa]
  (let [header "digraph finite_state_machine { \nrankdir=LR; size=\"8.5\"\n "
        final-state-style (str "node [ shape = doublecircle]; " (str/join "; " (:final-states sfa)) ";\n")
        initial-state-style (str "node [ shape = point ]; qi;\n")
        normal-state-style (str "node [ shape = circle ];\n")
        first-transition (str "qi -> " (:initial-state sfa) ";\n")
        transitions (reduce
                     (fn [trans-string {:keys [from to input]}]
                       (let [input (if (= (second input) Integer/MAX_VALUE) [(first input) "âˆž"] input)]
                         (str trans-string
                              "\n"
                              (if (nil? from) "nil" from)
                              " -> "
                              (if (nil? to) "nil" to)
                              " [ label = \"["
                              (first input) " "
                              (second input) "]\"];")))
                     ""
                     (apply concat (map second (filter map-entry? (:transitions sfa)))))
        footer "\n}"]
    (-> header
        (str final-state-style)
        (str initial-state-style)
        (str normal-state-style)
        (str first-transition)
        (str transitions)
        (str footer))))

(defn sfa->img
  "Display the image generated by calling `sfa->dot` on `sfa`."
  [sfa]
  (spit "tmp.dot" (sfa->dot sfa))
  (sh/sh "dot"
         (str "-Gdpi=" 300)
         (str "-T" "png")
         "tmp.dot"
         "-o"
         "tmp.png")
  (sh/sh "xdg-open" "tmp.png")
  (sh/sh "rm" "tmp.png")
  (sh/sh "rm" "tmp.dot"))
